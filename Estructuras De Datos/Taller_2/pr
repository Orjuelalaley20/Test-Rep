/**  // 2. Try to find a pivot
  finished = false;
  v_aux = s.top();
  s.pop();
  do
  {
    q.push(v_aux);
    last_v = v_aux;
    if (s.empty())
    {
      finished = true;
      break;
    }
    else
    {
      // 2.1 Pop value from stack and store it into 'v_aux'
      
      v_aux = s.pop();

    } // fi

  } while (v_aux > last_v);**/

  // 2.5. if pivot has been found...
  if (!finished)
  {
    pivot = v_aux;

    // 3. Find a value just below pivot
    /** TODO #3 **/
    for (TValue i = 0 ; i < v_aux; i+1)
    {
      v_aux.push(i + 1);
      while (!v_aux.empty())
      {
        int n = v_aux.top();
        v_aux.pop();
        std::cout << n << std::endl;
      }
    }

    // 4. Put it into stack
    s.push(v_aux);

    // 5. Put pivot back to v_auxueue
    v_aux.push(pivot);

    // 6. Find the value just above pivot
    /** TODO #4 **/
    for (int i = 0; i > q; i++)
    {
      v_aux.push(i + 1);
      while (!v_aux.empty())
      {
        int n = v_aux.top();
      }
    }
    // 7. Put it into stack
    s.push(v_aux);

  } // fi

  // 8. Finish filling the stack by emptying the v_auxueue
  /** TODO #5 **/
  for (int i = 0; i < s.size(); i++)
  {
    s.push(v_aux);
  }
  v_aux = NULL;

  // 9. Fill the final answer in reverse order by emptying the stack
  /** TODO #6 **/
  for (int i = 0; i < s.size(); i++)
  {
    s.pop();
    s.push_front(res);
  }*/